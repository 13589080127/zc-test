@startuml
title:实名认证多渠道流程
autonumber
业务服务->用户中心:用户认证(grantToken,name,certType,certNo,phone,authType 0-手机号+身份证+姓名;1-身份证+姓名)
用户中心->共享redis:校验grantToken
alt 校验通过
共享redis-->用户中心:用户信息
用户中心->用户中心:判断该用户此认证模式是否已认证
alt 已经认证
用户中心-->业务服务:返回用户已经认证
end
用户中心->用户中心:prefix+(用户唯一标识)哈希 查询redis是否存在
note left:用户唯一标识，C类用户id，此id是唯一的（不区分app）
alt 存在
用户中心->用户中心: 判断该用户当日剩余认证次数
alt 次数为0
用户中心-->业务服务:今日认证次数超限
end
end
用户中心->用户中心:prefix +(认证要素)哈希 查询redis是否存在
note left:查询错误数据
alt 存在
用户中心-->业务服务: 认证失败
end
用户中心->用户中心:prefix+(认证要素)哈希 查询redis和数据库是否存在
note left:查询正确数据;
alt redis不存在正确信息
用户中心->apollo:根据appId和几要素信息查询配置
alt 配置为空
用户中心->用户中心:默认走全部的渠道认证，逻辑和下面相同。
end
end
用户中心->用户中心:根据查询的配置渠道动态生成使用渠道实体列表
用户中心->用户中心:循环实体列表进行认证
用户中心->认证渠道:请求认证
认证渠道-->用户中心:返回认证结果，记录日志到es
alt 明确渠道返回异常
用户中心->用户中心:继续调用下一个渠道认证
else 渠道名曲返回认证结果
用户中心->用户中心:结束认证
end
用户中心->用户中心:转换错误码 判断是否认证成功
alt 认证成功
用户中心->用户中心:数据落地 c_b_users_rel,auth _info,user_auth_info
用户中心->用户中心: 根据(认证要素)hash+认证模式 删除auth_err_info
用户中心->用户中心:(认证要素)hash 放入redis
用户中心-->业务服务: 认证结果，B类用户号
else  明确认证失败
用户中心->共享redis:sha256哈希(认证要素) 生成哈希,addOrUpdate数据库(auth_err_info)，redis
用户中心->共享redis:prefix+sha256(用户唯一标识) 限制次数减1
用户中心-->业务服务:认证失败
else 其他失败
用户中心-->业务服务:认证失败
end
else redis存在正确信息
用户中心->用户中心:判断记录的更新时间和当前时间差值
alt 小于配置时间（例如30天）
用户中心->用户中心:根据认证id查询到c->b类用户号
用户中心->用户中心:合并当前c类用户和其他用户b类关系(c_b_users_rel)
用户中心-->业务服务:返回认证结果
else 大于30天
用户中心->用户中心:根据不同的认证模式使用工厂策略调用不同的认证方法
用户中心->认证渠道:进行认证,认证要素
认证渠道-->用户中心:认证结果 ，记录日志到es
用户中心->用户中心:转换错误码
alt 认证一致
用户中心->用户中心:更新数据库缓存(auth _info最后更新时间)
用户中心->用户中心:根据认证id查询到c->b类用户号
用户中心->用户中心:合并当前c类用户和其他用户b类关系(c_b_users_rel)
用户中心-->业务服务:认证成功 判断是否认证成功
else 认证不一致
用户中心->用户中心:更新数据库 更新为失效状态
用户中心->共享redis:prefix(认证要素) 哈希 存储错误数据库，错误信息redis
用户中心->共享redis:prefix+(用户唯一标识)哈希 限制次数减1
用户中心->用户中心:把认证信息置为失效状态，删除redis当前认证信息
用户中心-->业务服务:认证失败
else 其他失败
用户中心-->业务服务:认证失败
end
end
end
@enduml